.MExp Entity Edit

Lbl GOSL {
    .Get open slots on an island
    .r1: Island number
    .Returns the number of open slots between this island and the next
    .   (=number of open bytes/8)

    .Getting a pointer to the first open slot of the given island
    {r_1*2+ID}^r->G .pointer to start of island
    {G+ID}->H       .number of entities on island
    H+1*8+G->I        .pointer to first open slot

    .Getting a pointer to the next island's data, storing in H
    .   (or, if it's the last island, the end of the file)
    If {ID}^r=r_1
        {ID-2}^r->H
    Else
        {r_1+1*2+ID}^r->H
    End

    .Returning number of open slots
    H-I/8Return
}

Lbl GOSA {
    .Get open slots at
    .r1-r2: posX, posY
    .Returns number of open slots in the island at the cursor
    .   (returns 0 if no island)
    GIAT()->G
    GOSL(G)Return
}

Lbl COSL {
    .Create open slots
    .r1: Island number
    .r2: Num slots to create
    .Returns whether or not slots were successfully created

    .Making sure there's enough space to create the open slots
    IDUT()->G .IDAT memory used
    IDMU()->H .total IDAT memory
    H-G->G    .IDAT memory remaining

    r_2*8->H .amount of memory needed for new slots
    If H<=G
        .Can create slots
        .Shift each subsequent island forward by the num bytes needed for
        .   new slots
        {ID}^r->I .num islands
        I->J
        r_1->M    .stashing r_1 in M so it's not clobbered by CPRV
        While J>M
            .Moving island data
            {J*2+ID}^r->K
            {K+ID}->L
            CPRV(K+ID,K+H+ID,L+1*8)

            .Changing island pointer
            K+H->{J*2+ID}^r

            .Iterating to previous island
            J--
        End

        1Return
    End

    0Return
}

Lbl COSA {
    .Create open slots at
    .r1-r2: posX, posY
    .r3: num slots
    .Returns whether slots were successfully created
    .   (returns 0 if no island)
    GIAT()->G
    If G
        COSL(G,r_3)Return
    End
    0Return
}

Lbl PEOT {
    .Place entity on top
    .r1-r2: posX, posY
    .r3: Entity type
    .Returns the entity ID (not including the island ID)
    .   (returns 0 if entity could not be created)

    .Allocating stack
    S-5->S
    r_1->{S}
    r_2->{S+1}
    r_3->{S+2}
    A->{S+3}^r

    .Getting the island at the given position
    GIAT()->A
    Return!If A .returning early if no island

    .Finding the height to place at
    255->r_3
    GHEB()->G
    If G
        .If entities at this position, place just above top one
        {G}->H
        nib{GDB1ENTH*2+H}^r->I
        {G+5}+I->G
    Else
        .Else just place our entity on the ground
        GHAT({S},{S+1})+1->G
    End

    PENT(A,{S+2},{S},{S+1},G)->T

    .Fixing stack
    {S+3}^r->A
    S+5->S

    TReturn
}

Lbl PENT {
    .Place Entity
    .r1: Island number
    .r2: Entity type
    .r3-r4: posX, posY
    .r5: height
    .Returns the entity ID (not including the island ID)
    .   (returns 0 if entity could not be created)

    .Firstly, making sure that this island has open slots
    GOSL()->G
    If G
        .Finding the first open slot
        {r_1*2+ID}^r->G .pointer to start of island
        {G+ID}+1->H     .number of entities on island
        H*8+G+ID->I     .pointer to first open slot

        .Placing new entity data there
        r_2->{I}
        r_3->{I+1}
        r_4->{I+2}
        r_1->{I+3}
        H->{I+4}
        r_5->{I+5}
        0->{I+6}^r

        .Incrementing total entities on the island
        H->{G+ID}

        .Returning the entity ID
        HReturn
    End

    0Return
}

Lbl DENT {
    .Delete Entity
    .r1-r2: Entity ID (island, entity number)
    .Returns nothing

    .Getting the entity count on the island
    {r_1*2+ID}^r->G .pointer to start of island
    {G+ID}->H       .number of entities on island

    H-r_2->I        .number of entities after the entity to shift down
    If I
        .If this is not the last entity, copy down subsequent entities
        r_2*8+G+ID->J   .pointer to entity to delete
        Copy(J+8,J,I*8)

        .Also change all entity IDs of subsequent entities
        For(K,0,I-1)
            r_2+K->{K*8+J+4}
        End
    End

    .Decrementing number of entities on the island
    H-1->{G+ID}

    Return
}

Lbl DHEA {
    .Delete highest entity at
    .r1-r2: posX, posY
    .Returns nothing

    .Getting pointer to highest entity at the given point
    255->r_3
    GHEB()->G

    If G
        .Deleting the entity
        DENT({G+3},{G+4})
    End

    Return
}

Lbl CPAI {
    .Compact all islands
    .Performs compaction on IDAT, moving all islands closer together and
    .consolidating slots at the end of the file

    .Getting pointer to first byte after first island
    {ID}^r->G      .Num islands
    {ID+2}^r+ID->I .Pointer to first island
    {I}^r->J       .Num entities on first island
    J+1*8+I->H     .Pointer to first byte after first island

    .Moving subsequent islands down
    For(I,2,G)
        .Moving island down
        {I*2+ID}^r+ID->J  .Pointer to island
        {J}^r+1*8->K      .Num bytes on island
        Copy(J,H,K)

        .Updating pointer to island
        H-ID->{I*2+ID}^r

        .Resetting pointer to first byte after island
        H+K->H
    End

    Return
}
